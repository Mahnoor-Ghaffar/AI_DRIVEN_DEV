SpecifyPlus: It enables Spec-driven Vibe-coding by combining the rapid, conversational generation power of "vibe coding" with the structure and architectural coherence provided by the "spec-driven" methodology. This is a enhanced Spec-Driven Development toolkit with patterns & templates for building scalable multi-agent AI systems. It is a practical fork of github/spec-kit for spec-driven development of agentic AI systems. It provides patterns, templates, and reference projects for building scalable, distributed multi-agent apps with the OpenAI Agents SDK, MCP, A2A, and a cloud-native runtime stack‚ÄîDocker, Kubernetes, Dapr (Actors & Workflows), and Ray. Use it to define specs, spin up services, orchestrate agents, and ship production-ready stacks faster with guardrails and CI-friendly scaffolds.

The Most Important Question for Today's Developer

There's a question that every software developer should be asking themselves, one that will fundamentally shape the future of our profession: If AI writes the code, what's left for a developer to do?

Far from making developers obsolete, the rise of AI coding assistants clarifies their true value. The focus is shifting away from the mechanical act of writing syntax and toward the higher-order skills that drive real innovation:

Strategic Problem-Solving: The ability to deconstruct complex business challenges.
System Architecture: The vision to design resilient and efficient systems.
Incisive Diagnostics: The expertise to perform deep-seated root cause analysis.
Critical Inquiry: The wisdom to ask the right questions and define project scope.
Technical Governance: The judgment to establish standards and evaluate trade-offs.
Embracing this shift, our initiative is to leverage AI to develop advanced AI Agents. We are implementing a new workflow using tools like spec-kit-plus to facilitate this.

While this means development will become more conversational, it reinforces the need for foundational knowledge. A command of Python and technologies like the OpenAI Agents SDK, Kubernetes, Dapr, and Ray is indispensable. Developers must understand the code generated by LLMs to verify its quality, debug its flaws, and guide the AI toward optimal solutions.

The New Coding Revolution: Why AI-Native Programmers Will Win
At 28, Alexandr Wang has built Scale AI and now leads a major AI lab at Meta. His prediction? Every line of code he's ever written will eventually be replaced by AI-generated software.

A Generational Shift
Wang sees today's moment as equivalent to the PC revolution. Just as Gates and Zuckerberg gained an edge by tinkering with early computers, today's teenagers can dominate by spending thousands of hours "Spec-driven Vibe-coding" with AI.

The advantage won't come from traditional programming skills. It will come from growing up with AI as a collaborative partner‚Äîbuilding an intuition that older programmers, trained in pure human-to-machine coding, will struggle to match.

The Real Competition
This isn't about AI replacing programmers. It's about a new kind of programmer emerging: one who intuitively understands how to harness AI to bring ideas to life.

The developers who build the next generation of transformative software might not be grinding through CS degrees. They'll be young people who learned to think and create in partnership with AI.

The message is clear: The future belongs to those who start experimenting now. The revolution isn't coming‚Äîit's already here.

Use specifyplus or sp commands instead of specify.

Spec Kit Plus Logo
üå± Spec Kit Plus
Build high-quality software faster.
An open source toolkit that allows you to focus on product scenarios and predictable outcomes instead of vibe coding every piece from scratch.

Release GitHub stars License Documentation

Table of Contents
ü§î What is Spec-Driven Development?
‚ö° Get Started
üìΩÔ∏è Video Overview
ü§ñ Supported AI Agents
üîß Specify CLI Reference
üìö Core Philosophy
üåü Development Phases
üéØ Experimental Goals
üîß Prerequisites
üìñ Learn More
üìã Detailed Process
üîç Troubleshooting
üë• Maintainers
üí¨ Support
üôè Acknowledgements
üìÑ License
ü§î What is Spec-Driven Development?
Spec-Driven Development flips the script on traditional software development. For decades, code has been king ‚Äî specifications were just scaffolding we built and discarded once the "real work" of coding began. Spec-Driven Development changes this: specifications become executable, directly generating working implementations rather than just guiding them.

‚ö° Get Started
1. Install Specify CLI
Choose your preferred installation method:

Option 1: Persistent Installation (Recommended)
Install once and use everywhere:

# From PyPI (recommended)
pip install specifyplus

# Or with uv tools
uv tool install specifyplus

# Upgrade to latest later
pip install -U specifyplus
uv tool upgrade specifyplus
You may uninstall specifyplus:

pip uninstall specifyplus

# or

uv tool uninstall specifyplus
Then use the tool directly:

# Create new project
specifyplus init <PROJECT_NAME>
# or
sp init <PROJECT_NAME>

# Or initialize in existing project
specifyplus init . --ai claude
# or
sp init --here --ai claude

# Check installed tools
specifyplus check
# or
sp check
To upgrade Specify, see the Upgrade Guide for detailed instructions. Quick upgrade:

uv tool install specify-cli --force --from git+https://github.com/github/spec-kit.git
Option 2: One-time Usage
Run directly without installing:

uvx specifyplus --help
uvx specifyplus init <PROJECT_NAME>
# or
uvx sp init <PROJECT_NAME>
Benefits of persistent installation:

Tool stays installed and available in PATH
No need to create shell aliases
Better tool management with uv tool list, uv tool upgrade, uv tool uninstall
Cleaner shell configuration
2. Establish project principles
Use the /sp.constitution command to create your project's governing principles and development guidelines that will guide all subsequent development.

/sp.constitution Create principles focused on code quality, testing standards, user experience consistency, and performance requirements
3. Create the spec
Use the /sp.specify command to describe what you want to build. Focus on the what and why, not the tech stack.

/sp.specify Build an application that can help me organize my photos in separate photo albums. Albums are grouped by date and can be re-organized by dragging and dropping on the main page. Albums are never in other nested albums. Within each album, photos are previewed in a tile-like interface.
4. Create a technical implementation plan
Use the /sp.plan command to provide your tech stack and architecture choices.

/sp.plan The application uses Vite with minimal number of libraries. Use vanilla HTML, CSS, and JavaScript as much as possible. Images are not uploaded anywhere and metadata is stored in a local SQLite database.
5. Break down into tasks
Use /sp.tasks to create an actionable task list from your implementation plan.

/sp.tasks
6. Execute implementation
Use /sp.implement to execute all tasks and build your feature according to the plan.

/sp.implement
For detailed step-by-step instructions, see our comprehensive guide.

 VID√©o Overview
Want to see Spec Kit in action? Watch our video overview!

Spec Kit video header

ü§ñ Supported AI Agents
Agent    Support    Notes
Qoder CLI    ‚úÖ
Amazon Q Developer CLI    ‚ö†Ô∏è    Amazon Q Developer CLI does not support custom arguments for slash commands.
Amp    ‚úÖ
Auggie CLI    ‚úÖ
Claude Code    ‚úÖ
CodeBuddy CLI    ‚úÖ
Codex CLI    ‚úÖ
Cursor    ‚úÖ
Gemini CLI    ‚úÖ
GitHub Copilot    ‚úÖ
IBM Bob    ‚úÖ    IDE-based agent with slash command support
Jules    ‚úÖ
Kilo Code    ‚úÖ
opencode    ‚úÖ
Qwen Code    ‚úÖ
Roo Code    ‚úÖ
SHAI (OVHcloud)    ‚úÖ
Windsurf    ‚úÖ
üîß Specify CLI Reference
Learning subagents (optional)
Spec Architect ‚Äì docs-plus/02_start_prompting/02_qwen_code/04_subagents/prompts/0002-spec-architect.prompt.md
PHR/ADR Curator & Evaluator ‚Äì docs-plus/02_start_prompting/02_qwen_code/04_subagents/prompts/0004-phr-adr-curator.prompt.md
Note: Use specifyplus or sp commands instead of specify in this fork.

The specify command supports the following options:

Commands
Command    Description
init    Initialize a new Specify project from the latest template
check    Check for installed tools (git, claude, gemini, code/code-insiders, cursor-agent, windsurf, qwen, opencode, codex, shai, qoder)
version    Display version and system information
specifyplus init Arguments & Options
Argument/Option    Type    Description
<project-name>    Argument    Name for your new project directory (optional if using --here, or use . for current directory)
--ai    Option    AI assistant to use: claude, gemini, copilot, cursor-agent, qwen, opencode, codex, windsurf, kilocode, auggie, roo, codebuddy, amp, shai, q, bob, or qoder
--script    Option    Script variant to use: sh (bash/zsh) or ps (PowerShell)
--ignore-agent-tools    Flag    Skip checks for AI agent tools like Claude Code
--no-git    Flag    Skip git repository initialization
--here    Flag    Initialize project in the current directory instead of creating a new one
--force    Flag    Force merge/overwrite when initializing in current directory (skip confirmation)
--skip-tls    Flag    Skip SSL/TLS verification (not recommended)
--debug    Flag    Enable detailed debug output for troubleshooting
--github-token    Option    GitHub token for API requests (or set GH_TOKEN/GITHUB_TOKEN env variable)
Examples
# Basic project initialization
specifyplus init my-project

# Initialize with specific AI assistant
specifyplus init my-project --ai claude

# Initialize with Cursor support
specifyplus init my-project --ai cursor

# Initialize with Qoder support
specify init my-project --ai qoder

# Initialize with Windsurf support
specifyplus init my-project --ai windsurf

# Initialize with Amp support
specify init my-project --ai amp

# Initialize with SHAI support
specify init my-project --ai shai

# Initialize with IBM Bob support
specify init my-project --ai bob

# Initialize with PowerShell scripts (Windows/cross-platform)
specifyplus init my-project --ai copilot --script ps

# Initialize in current directory
specifyplus init . --ai copilot
# or use the --here flag
specifyplus init --here --ai copilot

# Force merge into current (non-empty) directory without confirmation
specifyplus init . --force --ai copilot
# or
specifyplus init --here --force --ai copilot

# Skip git initialization
specifyplus init my-project --ai gemini --no-git

# Enable debug output for troubleshooting
specifyplus init my-project --ai claude --debug

# Use GitHub token for API requests (helpful for corporate environments)
specifyplus init my-project --ai claude --github-token ghp_your_token_here

# Check system requirements
specifyplus check
Available Slash Commands
After running specifyplus init, your AI coding agent will have access to these slash commands for structured development:

Core Commands
Essential commands for the Spec-Driven Development workflow:

Command    Description
/sp.constitution    Create or update project governing principles and development guidelines
/sp.specify    Define what you want to build (requirements and user stories)
/sp.plan    Create technical implementation plans with your chosen tech stack
/sp.tasks    Generate actionable task lists for implementation
/sp.implement    Execute all tasks to build the feature according to the plan
Optional Commands
Additional commands for enhanced quality and validation:

Command    Description
/sp.clarify    Clarify underspecified areas (recommended before /sp.plan; formerly /quizme)
/sp.analyze    Cross-artifact consistency & coverage analysis (run after /sp.tasks, before /sp.implement)
/sp.checklist    Generate custom quality checklists that validate requirements completeness, clarity, and consistency (like "unit tests for English")
Environment Variables
Variable    Description
SPECIFY_FEATURE    Override feature detection for non-Git repositories. Set to the feature directory name (e.g., 001-photo-albums) to work on a specific feature when not using Git branches.
**Must be set in the context of the agent you're working with prior to using /sp.plan or follow-up commands.
üìö Core Philosophy
Spec-Driven Development is a structured process that emphasizes:

Intent-driven development where specifications define the "what" before the "how"
Rich specification creation using guardrails and organizational principles
Multi-step refinement rather than one-shot code generation from prompts
Heavy reliance on advanced AI model capabilities for specification interpretation
üåü Development Phases
Phase    Focus    Key Activities
0-to-1 Development ("Greenfield")    Generate from scratch
Start with high-level requirements
Generate specifications
Plan implementation steps
Build production-ready applications
Creative Exploration    Parallel implementations
Explore diverse solutions
Support multiple technology stacks & architectures
Experiment with UX patterns
Iterative Enhancement ("Brownfield")    Brownfield modernization
Add features iteratively
Modernize legacy systems
Adapt processes
üéØ Experimental Goals
Our research and experimentation focus on:

Technology independence
Create applications using diverse technology stacks
Validate the hypothesis that Spec-Driven Development is a process not tied to specific technologies, programming languages, or frameworks
Enterprise constraints
Demonstrate mission-critical application development
Incorporate organizational constraints (cloud providers, tech stacks, engineering practices)
Support enterprise design systems and compliance requirements
User-centric development
Build applications for different user cohorts and preferences
Support various development approaches (from vibe-coding to AI-native development)
Creative & iterative processes
Validate the concept of parallel implementation exploration
Provide robust iterative feature development workflows
Extend processes to handle upgrades and modernization tasks
üîß Prerequisites
Linux/macOS/Windows
Supported AI coding agent.
uv for package management
Python 3.11+
Git
If you encounter issues with an agent, please open an issue so we can refine the integration.

üìñ Learn More
Complete Spec-Driven Development Methodology - Deep dive into the full process
Detailed Walkthrough - Step-by-step implementation guide
üìã Detailed Process
Click to expand the detailed step-by-step walkthrough
üîç Troubleshooting
Git Credential Manager on Linux
If you're having issues with Git authentication on Linux, you can install Git Credential Manager:

#!/usr/bin/env bash
set -e
echo "Downloading Git Credential Manager v2.6.1..."
wget https://github.com/git-ecosystem/git-credential-manager/releases/download/v2.6.1/gcm-linux_amd64.2.6.1.deb
echo "Installing Git Credential Manager..."
sudo dpkg -i gcm-linux_amd64.2.6.1.deb
echo "Configuring Git to use GCM..."
git config --global credential.helper manager
echo "Cleaning up..."
rm gcm-linux_amd64.2.6.1.deb
üë• Maintainers
Den Delimarsky (@localden)
John Lam (@jflam)
ü§ù Contributing
We welcome contributions from the community! SpecifyPlus uses a test-first contribution model where you develop and validate commands in your own projects before contributing them to the core repository.

Quick Contribution Guide
# 1. Create and test your command locally
specifyplus init my-test-project --ai claude
cd my-test-project
# Develop your command in .specify/templates/commands/
# Test thoroughly with /sp.your-command

# 2. Contribute to the core repository
git clone https://github.com/panaversity/spec-kit-plus.git
# Copy your tested files and submit a PR
Contribution Resources
üîß Contributing Guide - Setup, testing, and submission process
‚ö° Quick Reference - Common command patterns and examples
Popular Contribution Areas
New slash commands (/sp.deploy, /sp.test, /sp.docs, etc.)
Template improvements for specifications, plans, and tasks
Shell scripts for automation (Bash/PowerShell)
Documentation and guides
Bug fixes and performance improvements
üí¨ Support
For support, please open a GitHub issue. We welcome bug reports, feature requests, and questions about using Spec-Driven Development.

üôè Acknowledgements
This project is heavily influenced by and based on the work and research of John Lam.

üìÑ License
This project is licensed under the terms of the MIT open source license. Please refer to the LICENSE file for the full terms.